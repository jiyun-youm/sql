--그룹함수
--AVG, SUM, MAX, MIN,COUNT(*), COUNT(컬럼)
SELECT SUM(SALARY),
       AVG(SALARY),
       MAX(SALARY),
       MIN(SALARY),
       COUNT(SALARY)
FROM EMPLOYEES WHERE JOB_ID LIKE 'SA%';

--MIN, MAX는 날짜타입, 문자에도 적용가능함
SELECT MIN(HIRE_DATE), MAX(HIRE_DATE) FROM EMPLOYEES;
SELECT MIN(FIRST_NAME), MAX(FIRST_NAME) FROM EMPLOYEES;
--COUNT()의 사용방법 2가지
SELECT COUNT(*),                 --전체 행수
       COUNT(COMMISSION_PCT)     --NULL이 아닌 데이터의 개수
FROM EMPLOYEES;
--그룹함수 쓸때 자주하는 실수-일반컬럼과 그룹함수를 같이 사용 X
SELECT FIRST_NAME,SUM(SALARY) FROM EMPLOYEES; --안됨
--WINDOW절을 사용하면 일반컬럼 옆에 그룹함수 값을 동시에 붙여서 출력할 수 있음
SELECT FIRST_NAME, 
       SUM(SALARY) OVER(), 
       AVG(SALARY) OVER(),
       COUNT(*) OVER()
FROM EMPLOYEES;

--그룹바이 구문 -WHERE절 다음 ORDER절 이전
SELECT DEPARTMENT_ID
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

--그룹함수를 같이 사용가능
SELECT DEPARTMENT_ID,  
       SUM(SALARY),
       AVG(SALARY),
       COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;
--주의할 점-그룹화 하지 않은 컬럼을 SELECT 절에 바로 넣을 수는 없음
SELECT DEPARTMENT_ID, FIRST_NAME
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;
--두 개 이상의 그룹화
SELECT DEPARTMENT_ID, JOB_ID, SUM(SALARY), COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID
ORDER BY DEPARTMENT_ID;
--평균 급여가 6000이상인 부서만 출력-X / 그룹바이의 조건을 쓰는 곳은 HAVING 따로 있음
SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
WHERE AVG(SALARY)>=6000
GROUP BY DEPARTMENT_ID;

--HAVING 그룹바이절의 조건을 작성하는 곳
SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY)>=6000;
--샐러리맨이 아닌 사람들의 직무별 급여 평균이 6000이상인 데이터의 평균, 합계, 평균 내림차순으로 정렬
SELECT JOB_ID,
       TRUNC(AVG(SALARY)) AS 평균,
       SUM(SALARY) AS 합계
FROM EMPLOYEES
WHERE JOB_ID NOT LIKE 'SA%'
GROUP BY JOB_ID
HAVING AVG(SALARY)>=6000
ORDER BY 평균 DESC;

--ROLLUP, CUBE, GROUPING->시험에 반드시 출제
SELECT DEPARTMENT_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID);

SELECT DEPARTMENT_ID, JOB_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID,JOB_ID);

--CUBE=ROLLUP+서브그룹의 총계까지 추가
SELECT DEPARTMENT_ID, JOB_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY CUBE(DEPARTMENT_ID,JOB_ID)
ORDER BY DEPARTMENT_ID;
--GROUPING 함수-그룹바이로 생성되었으면 0 반환, 롤업 OR 큐브로 생성되었으면 1 반환
SELECT DEPARTMENT_ID, JOB_ID, SUM(SALARY),
       GROUPING(DEPARTMENT_ID),
       GROUPING(JOB_ID)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID,JOB_ID)
ORDER BY DEPARTMENT_ID;
--------------------------------------------------------------------------------
--문제 1.
--사원 테이블에서 JOB_ID별 사원 수, 월급의 평균, 가장빠른 입사일을 구하세요. 
--월급의 평균 순으로 내림차순 정렬하세요.
--
SELECT JOB_ID, COUNT(JOB_ID), AVG(SALARY), MIN(HIRE_DATE)
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY AVG(SALARY)DESC;
--문제 2.
--사원 테이블에서 입사 년도 별 사원 수를 구하세요.
--
SELECT TO_CHAR(HIRE_DATE,'YYYY'),COUNT(*)
FROM EMPLOYEES
GROUP BY TO_CHAR(HIRE_DATE,'YYYY');

--

--문제 3.
--급여가 1000 이상인 사원들의 부서별 평균 급여를 출력하세요. 단 부서 평균 급여가 2000이상인 부서만 출력
--
SELECT DEPARTMENT_ID, TRUNC(AVG(SALARY))
FROM EMPLOYEES
WHERE SALARY>=1000
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY)>=2000;

--문제 4.
--사원 테이블에서 commission_pct(커미션) 컬럼이 null이 아닌 사람들의
--department_id(부서별) salary(월급)의 평균, 합계, count를 구합니다.
--조건 1) 월급의 평균은 커미션을 적용시킨 월급입니다.
--조건 2) 평균은 소수 2째 자리에서 절삭 하세요.
--
SELECT DEPARTMENT_ID, TRUNC(AVG(SALARY*(1+COMMISSION_PCT)),2), SUM(SALARY), COUNT(*)
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL
GROUP BY DEPARTMENT_ID;

--문제 5.
--부서아이디가 NULL이 아니고, 입사일은 05년도 인 사람들의 부서 급여평균과, 급여합계를 평균기준 내림차순합니다
--조건) 평균이 10000이상인 데이터만
--
SELECT AVG(SALARY),SUM(SALARY)
FROM EMPLOYEES
WHERE JOB_ID IS NOT NULL AND TO_CHAR(HIRE_DATE,'YYYY') LIKE '2005'
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY)>=10000
ORDER BY AVG(SALARY) DESC;
---------------------------------------------------------------
--문제 6.
--직업별 월급합, 총합계를 출력하세요
SELECT JOB_ID,SUM(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID);
